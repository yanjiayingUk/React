{"version":3,"sources":["ToDoList/Todoing.js","ToDoList/Todoinput.js","ToDoList/Todolist.js","index.js"],"names":["Todoing","todo","this","props","map","item","idx","key","onClick","del","Component","defaultProps","Todoinput","handleInput","e","keyCode","add","target","value","handleChange","setState","name","parseInt","bind","state","a","b","c","console","log","refs","focus","ref","onChange","onKeyDown","text","inp","type","Todolist","addItem","data","delItem","splice","obj","o","Object","assign","keys","forEach","ReactDOM","render","document","getElementById","className"],"mappings":"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","file":"static/js/main.9f17fa6a.chunk.js","sourcesContent":["import React,{ Component } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default class Todoing extends Component{\r\n    // delItem(idx,e){\r\n    //     console.log(e);\r\n    //     this.props.del(idx);\r\n    // }\r\n    render(){\r\n        var {todo}=this.props;\r\n        return (\r\n            // 下面大括号里面的是一个值，不用加;\r\n            <ul>\r\n                {\r\n                    todo.map((item,idx)=>\r\n                    <li key={idx}>\r\n                        {item}---<button onClick={()=>this.props.del(idx)}>删除</button>\r\n                    </li>)\r\n                }\r\n            </ul>\r\n        )\r\n    }\r\n}\r\n\r\n//类型检查\r\nTodoing.propTypes={\r\n    todo:PropTypes.array,\r\n    del:PropTypes.func\r\n}\r\nTodoing.defaultProps={\r\n    todo:[1,2,3,4,4,6]\r\n}","import React,{ Component } from 'react'\r\n\r\n//受控组件：value值被react控制的表单元素\r\n//可以实时获取表单元素的值(表单验证)   写法相对麻烦·\r\n//\r\nexport default class Todoinput extends Component{\r\n    constructor(){\r\n        super();\r\n        this.handleInput=this.handleInput.bind(this);\r\n        this.state={\r\n            a:'',\r\n            b:'',\r\n            c:''\r\n        }\r\n    }\r\n    handleInput=(e)=>{\r\n        //绑定this，事件处理函数写成箭头函数，或者用bind\r\n        if(e.keyCode ===13){//keyCode是键值，代表回车\r\n\r\n            // console.log(e.target.value);//e代表当前这个元素的节点\r\n            this.props.add(e.target.value);//没有上边的bind或者箭头函数就拿不到this,\r\n        }\r\n    }\r\n    handleChange=(e)=>{\r\n        this.setState({\r\n            [e.target.name]:parseInt(e.target.value===''?0:e.target.value)\r\n        })\r\n    }\r\n    componentDidMount(){\r\n        console.log(this.refs.a);\r\n        this.refs.a.focus();\r\n        // 自动执行\r\n    }\r\n    //出了render函数只能写属性和方法\r\n    render(){\r\n        return (\r\n            <div>\r\n                {/* <input value=\"abc\" onKeyDown={this.handleInput} text=\"text\" /> */}\r\n                <input ref='a' name=\"a\" onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} text=\"text\" />\r\n                +\r\n                <input name=\"b\" onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} text=\"text\" />\r\n                +\r\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} text=\"text\" />\r\n                =<p>{this.state.a+this.state.b+this.state.c}</p>\r\n\r\n                {/* 非受控组件：一次性获取或处理表单元素的值，适合一次性提交 */}\r\n                <input ref={(inp)=>{this.inp=inp}} type=\"text\" />\r\n\r\n                <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n            </div>\r\n        )\r\n    }\r\n    //上面函数需要传参，只能外边再套一层函数\r\n}\r\n//受控组件\r\n// 1.给input标签添加value属性，赋值为state的值\r\n// 2.给input标签绑定onChange事件，在事件处理函数中setState\r\n// 前两个必须\r\n// 3.一个事件处理函数控制多个表单元素时，给input标签加上name属性,\r\n// 事件处理函数中写：setState({[e.target.name]:e.target.value})\r\n\r\n\r\n\r\n\r\n\r\n// 打包 npm run build  新建仓库，传build文件夹\r\n","import React,{ Component } from 'react'\r\nimport Todoing from './Todoing'\r\nimport Todoinput from  './Todoinput'\r\n\r\nexport default class Todolist extends Component{\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            todo:[1,2,3]\r\n        }\r\n        //深拷贝、浅拷贝\r\n        // var obj={a:100};\r\n        // var o=obj;\r\n        // o.a=200;\r\n        // console.log(obj);\r\n\r\n        // var obj={a:100};\r\n        // var o={...obj};//这样就还是100\r\n        // o.a=200;\r\n        // console.log(obj);\r\n\r\n        // var obj={a:100,b:[1,2,3]};//浅拷贝\r\n        // var o={...obj};\r\n        // o.b[0]=200;\r\n        // console.log(obj);\r\n\r\n        // var obj={a:100,b:[1,2,3]};//深拷贝\r\n        // var o=JSON.parse(JSON.stringify(obj));\r\n        // o.b[0]=200;\r\n        // console.log(obj);\r\n\r\n        var obj={a:100,b:[1,2,3]};\r\n        var obj1={c:300}\r\n        var o=Object.assign(obj,obj1);\r\n        console.log(o);\r\n        console.log(o===obj);\r\n        console.log(Object.keys(obj))//obj属性名 组成的数组\r\n        Object.keys(obj).forEach((item)=>{\r\n            console.log(item);\r\n            console.log(obj[item]);\r\n        })\r\n    }\r\n    addItem=(data)=>{//子组件往父组件传，传一个函数\r\n        // console.log(data);\r\n        // this.state.todo.push(data);\r\n        console.log(this.state.todo);\r\n        this.setState({\r\n            //改变上边数组\r\n            todo:[...this.state.todo,data]\r\n        })\r\n    }\r\n    delItem=(idx,e)=>{\r\n        //1.不能直接改变或处理state，通过setState改变\r\n        console.log(e);\r\n        console.log(idx);\r\n        let todo=[...this.state.todo];//拷贝\r\n        todo.splice(idx,1);\r\n        //2.setState是异步执行\r\n        this.setState((state,props)=>{\r\n            console.log(state.todo);\r\n            return{\r\n                todo:todo\r\n            }\r\n        })\r\n\r\n        // 在setState里获取state可能会出错，不是你想要的值\r\n        //可以像上边那样，把第一个参数写成函数\r\n        // this.setState({\r\n                // todo:this.state.num+100\r\n        // },()=>{\r\n        //     console.log(this.state.todo);//执行完以后再执行这个\r\n        // })\r\n        // console.log(this.state.todo);//异步执行，先执行这个再执行上边的\r\n    }\r\n    render(){\r\n        return (\r\n            <div>\r\n                <Todoinput add={this.addItem}/>\r\n                <Todoing del={this.delItem} todo={this.state.todo}/>\r\n            </div>\r\n        )\r\n    }\r\n}","import React,{Fragment,Component} from 'react';//封装了一些方法，JSX方法,摁Ctrl键点击Fragment可以查看具体代码\nimport ReactDOM from 'react-dom';//管理所有react元素\n// import ShowTime from './ShowTime';\nimport Todolist from './ToDoList/Todolist'\nimport \"./index.css\";\n\n// class ShowTime extends Component{\n//     constructor(props){//不传这个参数在构造器当中拿不到this.props\n//         super(props);\n//         this.state={\n//             time:new Date().toLocaleString(),\n//             a:100,\n//             b:200\n//         }\n//         console.log(this.props);\n//         console.log('constructor');\n//         setTimeout(()=>{\n//             this.setState({\n//                 time:new Date().toLocaleString()\n//             })\n//         },1000)\n//     }\n\n//     shouldComponentUpdate(){//是否更新的一个判断\n//         if(this.state.a>10){\n//             return true;\n//         }\n//         else{\n//             return false;\n//         }\n//     }\n\n//     componentDidUpdate(preProps,preState,data){\n//         console.log(\"didupdate\");\n//         console.log(preState);\n//         console.log(this.state.time);/\n//     }\n//     getSnapshotBeforeUpdate(){\n//         console.log('getSnapshot');\n//         return {name:this.state.a}\n//     }\n//     componentDidMount(){\n//         console.log('didmount');//看控制台输出先后\n//     }\n\n//     render(){\n//         var {name,age}=this.props;\n//         console.log('render');\n//         return (\n//             <Fragment>\n//                 {/* 条件渲染 */}\n//                 {name.length>5?<div>姓名：{name}</div>:\"\"}\n//                 {name.length>5&&<div>姓名：{name}</div>}\n\n\n//                 <div>{this.state.time}</div>\n//                 {/*循环渲染 */}\n//                 <div>\n//                     {\n//                         age.map((item,index)=>{\n//                             if(index%2==0){\n//                                 return <p key={index}>{item}</p>\n//                             }\n//                         })\n//                     }\n//                 </div>\n//             </Fragment>\n//         )\n//     }\n// }\n\n\n//组件交互\n//父组件--->子组件：调用子组件 时添加属性，子组件通过props拿到传递的\n// 子组件--->父组件：\n// var num=[1,2,3,4,5];\n// ReactDOM.render(<ShowTime age={num} name=\"zhangsan\"/>,document.getElementById('root'))\n\nReactDOM.render(<Todolist/>,document.getElementById('root'))//根组件render只能有一个\n\n\n\n\n\n// 组件\n//组件内属性只读\n// function ShowTime(){\n//     console.log(props);\n//     // return (\n//     //     <div>\n//     //         <div></div>\n//     //         <div>{props.name}{new Date().toLocaleString()}</div>\n//     //     </div>\n//     // )//引用变量的地方都要加上一对{},最终只能返回一个对象，即一对div\n//     return (\n//         //在第一行解构出来就不用使用<React.Fragment></React.Fragment>\n//         <Fragment>\n//             <div>{props.name}{props.age}</div>\n//             <div>{props.name}{new Date().toLocaleString()}</div>\n//         </Fragment>\n//     )\n// }\n// ReactDOM.render(<ShowTime age={num} name=\"zhangsan\"/>,document.getElementById('root'))//<ShowTime />代表ShowTime里return的部分\n\n\n\n\n\n// 显示当前系统时间\n// function showTime(){\n//     var ele=<div>\n//         <p>当前时间是</p>\n//         <div>{new Date().toLocaleString()}</div>\n//     </div>;\n//     ReactDOM.render(ele,document.querySelector('#root'));//会改变不一样的地方，其他地方不动\n// }\n// showTime();\n// setInterval(showTime,1000);\n\n\n\n\n// 获取根节点\nvar str='react';\n//自己封装reader函数\nvar obj={\n    type:'div',\n    props:{\n        id:'bit',\n        class:'one',\n        children:['hello','react',{\n                type:'h1',\n                props:{\n                    id:'tit',\n                    class:'tit',\n                    children:['title','react']\n                }\n            }\n        ]\n    }\n};\nfunction render(obj,container){\n    var {type,props}=obj;\n    //文档碎片\n    var fragment=document.createDocumentFragment();\n    var ele=document.createElement(type);\n    for(var item in props){\n        if(item==='class'){\n            ele.className=props[item];\n        }\n        else if(item==='children'){\n            for(var i=0;i<props.children.length;i++){\n                if(typeof props.children[i]==='object'){\n                    render(props.children[i],ele);\n                }else{\n                    // ele.innerHTML+=props.children[i];//和下两行等效\n                    var txt=document.createTextNode(props.children[i]);\n                    ele.appendChild(txt);\n                }\n            }\n        }\n        else{\n            ele[item]=props[item];//[]这种方法直接是个变量\n        }\n    }\n    fragment.appendChild(ele);\n    container.appendChild(fragment);\n}\n// render(obj,document.getElementById('root'));\n//页面渲染过程\n//请求HTML页面，浏览器HTML解析器解析html文件，生成DOM树\n//link引入css文件、css解析器解析CSS，生成CSS对象模型，CSSOM和DOM tree结合生成一个render tree，最后浏览器绘制页面\n\n\n\n\n\n//页面回流(重排reflow):DOM结构变化、内容变化、大小、位置的变化、显示的变化(回流代价更大)\n//页面重绘(repaint):颜色的变化(背景色、字体颜色、边框颜色)\n//回流一定会引起重绘，重绘不一定引起回流\n\n// 1.先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var div=document.getElementById('root');\n// var str=\"\";\n// for(var i=0;i<1000;i++){\n//     str+='<p>'+i+'<p>'\n// }\n// div.innerHTML=str;//比直接往div里一个一个添加优化\n// console.timeEnd('time');\n// 2.对于样式处理,声明一个css类\nvar div=document.getElementById('root');\n// div.style.width='100px';\n// div.style.height='100px';\n// div.stype.background='red';\n\ndiv.className='active';//一次性引入也能提升性能\n// 3.offsetLeft,offsetWidth等都会引起回流，要慎用\n// console.log(div.offsetLeft);\n// var wid=div.offsetWidth;\n// setInterval(()=>{\n//     wid+=1;\n//     div.style.width=wid+'px';\n// },100)\n//4.文档碎片(内存中的一个变量)\n\n\n\n//react技术实践\n//var ele=<h1 class=\"tit\">哈哈哈 {str}</h1>;//不用加\"\"，不是一个标签，而是一个对象\n//babel编译，返回一个对象\n// var ele = <h1 class=\"tit\">hello <p>react</p></h1>;\n// var ele = React.createElement(\n//     'h1',\n//     {id:'tit',class:'title'},\n//     'hello',\n//     React.createElement(\n//         'p',\n//         {id:'t',class:'tit'},\n//         'react')\n// );\n// ReactDOM.render(ele.getElementById('root'));\n\n\n\n"],"sourceRoot":""}